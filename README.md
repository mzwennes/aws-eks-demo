# EKS deployment
## Summary

This repository is separated into three folders:

- `.github/workflows` - Github Action workflow.
- `app` - Flask application and the Kubernetes manifests.
- `terraform` - Contains the infrastructure code.

**Main characteristics**
- sad

**General Improvements**
- Both the app and API are served as a single application but they could be separated to support better isolation and scaling
- Add a CICD pipeline for the Terraform (with something like [Atlantis](https://www.runatlantis.io/))
- Store the state in a backend
- Currently the `AWS Load Balancer Controller` is deployed with the Terraform Helm provider. For demo purposes this is fine but I prefer
to manage Kubernetes manifests in a pull-based manner with tools such as [ArgoCD](https://argo-cd.readthedocs.io/en/stable/) or [Flux](https://fluxcd.io/)

## Application

The `app` folder contains a simple Flask application which retrieves the app version with an environment variable named: `APP_VERSION`. [Gunicorn](https://gunicorn.org/) is added in front of Flask as a webserver during the build phase.


**Run it locally**

```bash
FLASK_APP=server.py flask run
```

## Build

This project uses [Buildpacks](https://buildpacks.io) to build and publish the container image to Docker Hub. Buildpacks are a alternative to writing a `Dockerfile` by hand. 

Locally the `pack` command can be used to build the image:

```bash
pack build zwensman/simple-app:0.0.1 \
    --buildpack paketo-buildpacks/python \
    --builder paketobuildpacks/builder:base
```

I am not sure how I feel about Buildpacks. In larger projects or organizations it can be a great tool to standardize the build process for different toolchains. However the lack of control over the default Buildpacks requires the use of customized Buildpacks in cases where vulnerabilties are not patched.

> Initially I started out with a multi-stage Docker file which used the experimental [python3 distroless image](https://github.com/GoogleContainerTools/distroless/blob/main/experimental/python3/README.md). The final image was only 79.9MB (compared to the 303MB image which was generated by Buildpacks), however a Trivy scan detected quite a few vulnerabilities. 

## Deployment

This environment variable gets injected in the Kubernetes deployment and is overwritten in the Kustomization file which gets updated when a new tag is pushed.

## Infrastructure

**Improvements**
